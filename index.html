<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>THE WORLD IS MINE</title>
<!-- ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ -->
<meta name="apple-mobile-web-app-title" content="TWIM">

<!-- ÿ£ŸäŸÇŸàŸÜÿ© ÿßŸÑŸáŸàŸÖ ÿ≥ŸÉÿ±ŸäŸÜ -->
<link rel="apple-touch-icon" href="icon.png">

<!-- ÿ¨ÿπŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ full screen -->
<meta name="apple-mobile-web-app-capable" content="yes">

<!-- ŸÑŸàŸÜ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ≠ÿßŸÑÿ© -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <link rel="icon" href="icon.png">
  <style>
    body { font-family: Arial, sans-serif; background:#111; color:#fff; padding:20px; }
    h1 { text-align:center; }
    .section { margin-top:16px; padding:14px; border:1px solid #444; border-radius:10px; }
    input, select { width:100%; padding:10px; margin-top:8px; border-radius:8px; border:none; }
    button { width:100%; padding:12px; margin-top:10px; background:#f00; color:#000; font-weight:bold; border:none; border-radius:8px; cursor:pointer; }
    .result-box { margin-top:10px; padding:10px; background:#222; border-radius:8px; color:#ddd }
    label { display:block; margin-top:6px; color:#ddd }
    .row { display:flex; gap:10px; }
    .col { flex:1 }
    .small { padding:8px; font-size:14px }
    #nextRoll { margin-top:6px; font-weight:bold; color:#0f0 }
  </style>
</head>
<body>
  <h1>THE WORLD üìçS MINE</h1>

  <div class="section">
    <label>ROLLS</label>
    <div id="nextRoll">Next Roll: -</div>
    <input id="rollsInput" placeholder="Enter results sequence (example: VXVXXV or V X V X)" oninput="updateNextRoll()" />

    <div class="row">
      <div class="col">
        <label>BASE BET</label>
        <input id="baseBetInput" type="number" value="10" />
      </div>
      <div class="col">
        <label>MULTIPLIER</label>
        <input id="multiplierInput" type="number" step="0.1" value="2" />
      </div>
    </div>

    <label>BUDGET</label>
    <input id="budgetInput" type="number" placeholder="Enter starting budget (example: 2560)" />

    <button class="small" onclick="simulate()">START</button>
  </div>

  <div id="results" class="section">
    <h2>RESULTS</h2>
    <div class="result-box" id="output"></div>
  </div>

<script>
function normalizeSequence(raw) {
  if (!raw) return [];
  return raw.replace(/[^XVxv]/g, '').toUpperCase().split('');
}

// SIMULATION: real money changes
function simulate() {
  const seq = normalizeSequence(document.getElementById('rollsInput').value || '');
  let B = Number(document.getElementById('budgetInput').value) || 0;
  const B_start = B;
  const base = Number(document.getElementById('baseBetInput').value) || 10;
  const mult = Number(document.getElementById('multiplierInput').value) || 2;

  let bet = base;
  let totalLosses = 0;
  let longestLoseStreak = 0;
  let currentLoseStreak = 0;

  // STATES (same logic as preview)
  let waitingForV_afterX = false;  // after any X that was entered, wait for V
  let lossCountForTwoVLock = 0;    // counts consecutive entered bet-losses (must be reset on an entered win)
  let vSeenForLock = 0;            // counts V occurrences during two-V waiting
  let inTwoVLock = false;          // waiting for two V after 2 consecutive bet-losses
  let armedToEnterNext = false;    // next roll will be entered (bet)

  for (let i = 0; i < seq.length; i++) {
    const r = seq[i];

    // 1) If next roll is armed (we should bet on this roll)
    if (armedToEnterNext) {
      armedToEnterNext = false;
      if (B >= bet) {
        if (r === 'V') {
          // entered win: reset consecutive loss counter
          B += Math.round(bet);
          bet = base;
          currentLoseStreak = 0;
          lossCountForTwoVLock = 0; // <- reset consecutive entered losses on win
        } else {
          // entered loss
          B -= Math.round(bet);
          totalLosses++;
          currentLoseStreak++;
          if (currentLoseStreak > longestLoseStreak) longestLoseStreak = currentLoseStreak;
          bet = Math.round(bet * mult);
          lossCountForTwoVLock++;
          if (lossCountForTwoVLock >= 2) {
            inTwoVLock = true;
            vSeenForLock = 0;
          }
          // after entering and losing, we must wait for V before next entry
          waitingForV_afterX = true;
        }
      }
      continue; // processed this roll
    }

    // 2) If in two-V lock, count V's until 2 then arm next
    if (inTwoVLock) {
      if (r === 'V') {
        vSeenForLock++;
        if (vSeenForLock >= 2) {
          inTwoVLock = false;
          lossCountForTwoVLock = 0;
          vSeenForLock = 0;
          armedToEnterNext = true; // the roll after the 2nd V will be bet
        }
      }
      continue; // while locked we do not bet
    }

    // 3) If waiting for V after an entered X, only arm next after V
    if (waitingForV_afterX) {
      if (r === 'V') {
        waitingForV_afterX = false;
        armedToEnterNext = true; // bet next roll
      }
      continue; // do not bet on rolls while waiting
    }

    // 4) Normal behaviour: when not locked/waiting/armed
    if (r === 'V') {
      if (B >= bet) {
        // treat this V as an entered win
        B += Math.round(bet);
        bet = base;
        currentLoseStreak = 0;
        lossCountForTwoVLock = 0; // reset consecutive loss-on-win
      }
    } else if (r === 'X') {
      // This X is considered an entered loss in normal mode
      if (B >= bet) {
        B -= Math.round(bet);
        totalLosses++;
        currentLoseStreak++;
        if (currentLoseStreak > longestLoseStreak) longestLoseStreak = currentLoseStreak;
        bet = Math.round(bet * mult);
        lossCountForTwoVLock++;
        if (lossCountForTwoVLock >= 2) {
          inTwoVLock = true;
          vSeenForLock = 0;
        }
      }
      // After an entered X we must wait for V before next entry
      waitingForV_afterX = true;
    }
  }

  const net = B - B_start;
  let out = '';
  out += `<strong>BUDGET (START):</strong> ${B_start}<br>`;
  out += `<strong>NOW:</strong> ${B}<br>`;
  out += `<strong>NET PROFIT:</strong> ${net}<br>`;
  out += `<strong>Total ROLLS:</strong> ${seq.length}<br><br>`;
  out += `<strong>Longest LOSSES Streak (bet-losses):</strong> ${longestLoseStreak}<br>`;
  out += `<strong>Total LOSSES (bets lost):</strong> ${totalLosses}<br>`;

  document.getElementById('output').innerHTML = out;
  // update preview using same rules
  updateNextRoll();
}

// PREVIEW: compute whether the NEXT roll (one after the typed sequence) WOULD be entered according to the exact same rules
function updateNextRoll() {
  const seq = normalizeSequence(document.getElementById('rollsInput').value || '');

  // We simulate only the state machine (no money changes), but exactly like simulate() decisions about which rolls were entered
  let waitingForV_afterX = false;
  let lossCountForTwoVLock = 0; // consecutive entered losses
  let vSeenForLock = 0;
  let inTwoVLock = false;
  let armedToEnterNext = false;

  for (let i = 0; i < seq.length; i++) {
    const r = seq[i];

    if (armedToEnterNext) {
      // This roll is entered
      armedToEnterNext = false;
      if (r === 'V') {
        // entered win ‚Äî reset consecutive loss counter
        waitingForV_afterX = false;
        lossCountForTwoVLock = 0;
      } else {
        // entered loss ‚Äî counts toward consecutive entered losses
        lossCountForTwoVLock++;
        waitingForV_afterX = true; // after an entered X we wait for V
        if (lossCountForTwoVLock >= 2) {
          inTwoVLock = true;
          vSeenForLock = 0;
        }
      }
      continue;
    }

    if (inTwoVLock) {
      if (r === 'V') {
        vSeenForLock++;
        if (vSeenForLock >= 2) {
          inTwoVLock = false;
          lossCountForTwoVLock = 0;
          vSeenForLock = 0;
          armedToEnterNext = true; // the roll AFTER second V will be entered
        }
      }
      continue;
    }

    if (waitingForV_afterX) {
      if (r === 'V') {
        waitingForV_afterX = false;
        armedToEnterNext = true; // we will enter the next roll
      }
      continue;
    }

    // Normal mode ‚Äî not waiting/locked/armed
    if (r === 'V') {
      // entered win ‚Äî reset consecutive entered losses
      lossCountForTwoVLock = 0;
      waitingForV_afterX = false;
    } else if (r === 'X') {
      // entered loss in normal mode
      lossCountForTwoVLock++;
      waitingForV_afterX = true;
      if (lossCountForTwoVLock >= 2) {
        inTwoVLock = true;
        vSeenForLock = 0;
      }
    }
  }

  // After processing the typed sequence, determine whether the next roll (the one after the typed sequence) WOULD be entered
  let nextAllowed = false;
  if (armedToEnterNext) nextAllowed = true;
  else if (inTwoVLock) nextAllowed = false;
  else if (waitingForV_afterX) nextAllowed = false;
  else nextAllowed = true;

  document.getElementById('nextRoll').innerText = 'Next Roll: ' + (nextAllowed ? 'Yes' : 'No');
}

// initialize preview
updateNextRoll();
</script>
</body>
</html>
